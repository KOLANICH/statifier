# to be sourced from bash

# Copyright (C) 2004 Valery Reznic
# This file is part of the Elf Statifier project
# 
# This project is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License.
# See LICENSE file in the doc directory.

# This file contains variable and functions common for
# statifier's scripts

function SetVariables
{
	[ $# -ne 1 -o "x$1" = "x" ] && {
		Echo "$0: Usage: SetVariable <work_dir>"
		return 1
	}
	# Temporary Work Directory - WORK_DIR
	local WORK_DIR=$1
	# Directory for files to be sourced 
	# and temp files for use in different stages
	WORK_COMMON_DIR=$WORK_DIR/common

	LOADER_SYMBOLS=$WORK_COMMON_DIR/ld.syms
	LOADER_PHDRS=$WORK_COMMON_DIR/ld.phdrs

	OPTION_SRC=$WORK_COMMON_DIR/option.src
	COMMON_SRC=$WORK_COMMON_DIR/common.src
	LOADER_SRC=$WORK_COMMON_DIR/loader.src

	# Directoty for adjusted files.
	WORK_GDB_CMD_DIR=$WORK_DIR/gdb_cmd

	# Directory for segment files
	WORK_DUMPS_DIR=$WORK_DIR/dumps

	# Directory for misc output from gdb
	WORK_GDB_OUT_DIR=$WORK_DIR/gdb_out

	REGISTERS_FILE=$WORK_GDB_OUT_DIR/registers
	CORE_FILE=$WORK_GDB_OUT_DIR/core

	# Directory for temp files built during new exe file constructions.
	WORK_OUT_DIR=$WORK_DIR/out

	return 0
}

function Echo
{
	echo "$@" 1>&2
}

function GetSymbol
{
	# This function print out address of 'Symbol' in hex.
	# I am looking for symbol in the output of 
	# readelf --syms $Interpreter.
	# Function work as following:
	#  1. Symbol NOT FOUND.
	#  1.1. If 'IsMandatory'=1, error message will be printed 
	#       and return status 1
	#  1.2. If 'IsMandatory' != 1, i.e Symbol is optional,
	#       value '0x0' will be prined and return status 0.
	# 2. Symbol WAS FOUND.
	#    return status - 0 
	# 2.1. If VirtAddr = 0x0, then found value is offset,  
	#      and value + base_addr will be printed.
	# 2.2. If  VirtAddr != 0x0 then found value is absolute
	#      address and it will be printed out. 
	#      I saw loader with VirtAddr != 0x0 on one system
	#      with 2.6.* kernel
	[ $# -ne 2 -o "x$1" = "x" -o "x$2" = "x" ] && {
		Echo "$0: Usage: GetSymbol_Symtab <Symbol> <IsMandatory>"
		return 1
	}
	local Symbol=$1
	local IsMandatory=$2
	local IsValueAbsolute=""

	local MsgNotFound="$0: Symbol '$Symbol' not found in the interpreter '$val_interpreter'"
	local MsgNoIdea="$0: internal error: no idea how to find '$Symbol' in the interpreter '$val_interpreter' without symtab."

	local Value
	if [ "X$val_interpreter_has_symtab" = "Xyes" ]; then
		# Interpreter has symtab. Good. Just try to fond symbol in.
		Value=`awk -vSymbol="$Symbol" '{
			if ($NF == Symbol) {
				print "0x" $2; 
				exit 0;
			}
		}' < $LOADER_SYMBOLS` || return
	else
		# No symtab in the interpreter. Not so good.
		# I'll need for each symbol run it's autodetect test.
		# One more thing:
		# some tests  return offset from the interpreter's load address,
		# and other - absolute address. 
		# In the later case I need set variable IsValueAbsolute
		local PgmName
		case "$Symbol" in
			
			_dl_platformlen)
				Value=""  # No way to find it.
			;;

			_dl_start_user)
				Value=`$D/elf_find_pattern $val_interpreter 0x89 0xc7` || return
			;;


			_dl_argc     | \
			_dl_argv     | \
			_dl_auxv     | \
			_dl_platform | \
			_environ) 
				IsValueAbsolute="yes"
				PgmName="$D/find$Symbol"
				local Found=-1
				Value=`                 \
					$PgmName        \
					$Found          \
					$val_base_addr  \
					$val_virt_addr  \
					$val_virt_addr2 \
					$val_size2      \
				` || return
			;;

			*)
				Echo "$MsgNoIdea"
				return 1
			;;
		esac
	fi

	if [ "x$Value" = "x" ]; then
		# Symbol not found
		if [ "x$IsMandatory" = "x1" ]; then
			Echo "$MsgNotFound"
			return 1 
		else
			Value="0x0"
		fi
	else
		# Symbol found
		[ "x$IsValueAbsolute" = "x" ] && {
			[ "x$val_virt_addr" = "x0x0" ] && {
				Value=$[Value + $val_base_addr] || return
			}
		}
	fi

	printf "0x%x" $Value || return
	return 0
}
